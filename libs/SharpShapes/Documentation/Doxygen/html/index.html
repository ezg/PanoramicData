<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BrownRecognition API: Overview</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="brown-logo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">BrownRecognition API
   &#160;<span id="projectnumber">v1.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('index.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Overview </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="a"></a>
Types and Modes</h2>
<p>The BrownRecognition <a class="el" href="class_brown_recognition_a_p_i_1_1_a_p_i.html" title="Entry point for all calls to the BrownRecognition API.">API</a> supports different types and modes of recognition. The following sections give an overview of how they can be used.</p>
<h3><a class="anchor" id="aa"></a>
Shape Recognition</h3>
<p>Shape recognition is intended to create a shape from one or more user input strokes. The provided methods will return a <a class="el" href="class_brown_recognition_common_1_1_brown_shape.html" title="Encapsulates a recognized shape.">BrownRecognitionCommon.BrownShape</a> (or null) that has an attached shape type (see <a class="el" href="namespace_brown_recognition_common.html#a86340ddb3d90188573ed7b4484046ec3" title="Enumeration of all the differnet shape types supported by the BrownRecognition API.">BrownRecognitionCommon.ShapeType</a>) and a list of points that make up the clean version of this shape. <br/>
 <br/>
 Example of how to use the one stroke shape recognition: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// whatever the calling application uses as its stroke representation. </span>
 ApplicationStroke appStroke; 
 
 <span class="comment">// create a BrownInputStroke</span>
 BrownInputStroke brownStroke = <span class="keyword">new</span> BrownInputStroke(appStroke.ToPointArray(), appStroke);
 
 <span class="comment">// call the recognizer</span>
 BrownShape brownShape = BrownRecognitionAPI.API.RecognizeBrownShape(brownStroke);
 <span class="keywordflow">if</span> (brownShape != null) {
     <span class="comment">// once a shape has been recognized, the application probably</span>
     <span class="comment">// wants to remove their stroke from the UI.</span>
     <span class="keywordflow">foreach</span> (BrownInputStroke bis <span class="keywordflow">in</span> brownShape.BrownInputStrokes) {
         UI.remove((ApplicationStroke) bis.Data);
     }
     
     <span class="comment">// add a corresponding shape to the UI.</span>
     <span class="keywordflow">if</span> (brownShape.ShapeType == <a class="code" href="namespace_brown_recognition_common.html#a86340ddb3d90188573ed7b4484046ec3" title="Enumeration of all the differnet shape types supported by the BrownRecognition API.">ShapeType</a>.Rect) {
         UI.add(<span class="keyword">new</span> Rectangle(brownShape.ShapePoints));
     }
     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (brownShape.ShapeType == <a class="code" href="namespace_brown_recognition_common.html#a86340ddb3d90188573ed7b4484046ec3" title="Enumeration of all the differnet shape types supported by the BrownRecognition API.">ShapeType</a>.Circle) {
         ...
     }
     ...
 }
</pre></div><p><br/>
 Example of how to use the multi stroke shape recognition: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// List of all lines that could be part of a new shape</span>
 List&lt;BrownShape&gt; lineShapes = <span class="keyword">new</span> List&lt;BrownShape&gt;();
 
 <span class="comment">// Add whatever makes sense to the lineShapes list, i.e. already recognized</span>
 <span class="comment">// shapes, new input strokes etc. </span>
 <span class="keywordflow">foreach</span> (UIShape s <span class="keywordflow">in</span> UI.Lines) {
     BrownShape brownShape = s.ConvertToBrownShape();
     <span class="comment">// make sure that the underlying BrownInputStroke is set and that </span>
     <span class="comment">// the Data propery has a value that allows you to backtrack to the UIShape. </span>
     brownShape.BrownInputStrokes[0].Data = s;
     lineShapes.Add(brownShape);
 }
 <span class="keywordflow">foreach</span> (ApplicationStroke s <span class="keywordflow">in</span> UI.Strokes) {
     <span class="comment">// either convert an application stroke yourself or call RecognizeBrownShape()</span>
     <span class="comment">// as in the example above.</span>
     BrownShape brownShape = s.ConvertToBrownShape();
     lineShapes.Add(brownShape);
 }
 
 <span class="comment">// call the recognizer</span>
 BrownShape brownShape = BrownRecognitionAPI.API.RecognizeBrownShape(lineShapes);
 <span class="keywordflow">if</span> (brownShape != null) {
     <span class="comment">// once a shape has been recognized, the application probably</span>
     <span class="comment">// wants to remove their stroke from the UI.</span>
     <span class="keywordflow">foreach</span>(BrownInputStroke bis <span class="keywordflow">in</span> brownShape.BrownInputStrokes) {
         <span class="keywordflow">if</span> (bis.Data is ApplicationStroke) {
             UI.remove((ApplicationStroke) bis.Data);
         }
         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bis.Data is UIShape) {
             UI.remove((UIShape) bis.Data);
         }
     }
     
     <span class="comment">// add a corresponding shape to the UI.</span>
     <span class="keywordflow">if</span> (brownShape.ShapeType == <a class="code" href="namespace_brown_recognition_common.html#a86340ddb3d90188573ed7b4484046ec3" title="Enumeration of all the differnet shape types supported by the BrownRecognition API.">ShapeType</a>.Rect) {
         UI.add(<span class="keyword">new</span> Rectangle(brownShape.ShapePoints));
     }
     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (brownShape.ShapeType == <a class="code" href="namespace_brown_recognition_common.html#a86340ddb3d90188573ed7b4484046ec3" title="Enumeration of all the differnet shape types supported by the BrownRecognition API.">ShapeType</a>.Circle) {
         ...
     }
     ...
 }
</pre></div><h3><a class="anchor" id="ab"></a>
Template Recognition with Feedback</h3>
<p>This mode can be used to give the user some intermediate feedback while he is drawing a template. In order to do that, the Application needs to trigger the template recognition after every new stroke and needs to keep track of what previous strokes have been recognized as. <br/>
 <br/>
 Example of how to use template recognition with feedback: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// List of all shapes that could be part of a template</span>
 List&lt;BrownShape&gt; brownShapes = <span class="keyword">new</span> List&lt;BrownShape&gt;();
 
 <span class="comment">// Add whatever makes sense to the brownShapes list, i.e. already recognized</span>
 <span class="comment">// shapes, already cleaned up template shapes, new input strokes etc. </span>
 <span class="keywordflow">foreach</span> (UIShape s <span class="keywordflow">in</span> UI.Shapes) {
     BrownShape brownShape = s.ConvertToBrownShape();
     <span class="comment">// make sure that the underlying BrownInputStroke is set and that </span>
     <span class="comment">// the Data propery has a value that allows you to backtrack to the UIShape. </span>
     brownShape.BrownInputStrokes[0].Data = s;
     brownShapes.Add(brownShape);
 }
 <span class="keywordflow">foreach</span> (ApplicationStroke s <span class="keywordflow">in</span> UI.Strokes) {
     <span class="comment">// either convert an application stroke yourself or call RecognizeBrownShape()</span>
     <span class="comment">// as in the example above.</span>
     BrownShape brownShape = s.ConvertToBrownShape();
     brownShapes.Add(brownShape);
 }
 
 <span class="comment">// call the recognizer</span>
 List&lt;BrownTemplate&gt; recognizedTemplates = BrownRecognitionAPI.API.RecognizeBrownTemplate(brownShapes);
 
 <span class="comment">// for feedback: update your UI according to what templates have been recognized.</span>
 <span class="comment">// e.g. color shapes that are part of a template, etc. </span>
 UI.Feedback(recognizedTemplates);
</pre></div><h3><a class="anchor" id="ac"></a>
Template Recognition without Feedback</h3>
<p>This mode can be used if template recognition is triggered by the user (e.g. with a button). This This method will be slower than the feedback one, since every input stroke will first be passed to the shape recognizer. It is not intended to be called on every new stroke. <br/>
 <br/>
 Example of how to use template recognition without feedback: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// List of all input strokes that could be part of a template</span>
 List&lt;BrownInputStroke&gt; brownInputStrokes = <span class="keyword">new</span> List&lt;BrownInputStroke&gt;();
 
 <span class="comment">// Add whatever makes sense to the brownInputStrokes list, i.e. already recognized</span>
 <span class="comment">// shapes, already cleaned up template shapes, new input strokes etc. </span>
 <span class="keywordflow">foreach</span> (UIShape s <span class="keywordflow">in</span> UI.Shapes) {
     BrownInputStroke brownStroke = s.ConvertToBrownInputStroke();
     <span class="comment">// make sure that the Data propery has a value that allows you to backtrack to the UIShape. </span>
     brownStroke.Data = s;
     brownInputStrokes.Add(brownShape);
 }
 <span class="keywordflow">foreach</span> (ApplicationStroke s <span class="keywordflow">in</span> UI.Strokes) {
     BrownInputStroke brownStroke = <span class="keyword">new</span> BrownInputStroke(s.ToPointArray(), s);
     brownInputStrokes.Add(brownStroke);
 }
 
 <span class="comment">// call the recognizer</span>
 List&lt;BrownTemplate&gt; recognizedTemplates = BrownRecognitionAPI.API.RecognizeBrownTemplate(brownInputStrokes);
</pre></div><h3><a class="anchor" id="ad"></a>
Template Clean-up</h3>
<p>After a template got recognized, the <a class="el" href="class_brown_recognition_a_p_i_1_1_a_p_i.html" title="Entry point for all calls to the BrownRecognition API.">API</a> provides a method to get a set of clean shapes building the corresponding template. <br/>
 <br/>
 Example of how to use template clean-up: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// the template you want to clean up</span>
 BrownTemplate <span class="keyword">template</span>; 
 
 <span class="comment">// call the API to get a list of clean shapes. </span>
 List&lt;BrownShape&gt; elements = BrownRecognitionAPI.API.GetCleanTemplateShapes(<span class="keyword">template</span>);
 
 <span class="keywordflow">foreach</span> (BrownShape element <span class="keywordflow">in</span> elements) {
     <span class="comment">// once we have clean shapes we want to remove everything that was used</span>
     <span class="comment">// to create a clean shape from the UI. </span>
     <span class="keywordflow">foreach</span> (BrownInputStroke bis <span class="keywordflow">in</span> element.BrownInputStrokes) {
         <span class="keywordflow">if</span> (bis.Data is ApplicationStroke) {
             UI.remove((ApplicationStroke) bis.Data);
         }
         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bis.Data is UIShape) {
             UI.remove((UIShape) bis.Data);
         }
     }
     
     <span class="comment">// add a corresponding shape to the UI.</span>
     <span class="keywordflow">if</span> (element.ShapeType == <a class="code" href="namespace_brown_recognition_common.html#a86340ddb3d90188573ed7b4484046ec3" title="Enumeration of all the differnet shape types supported by the BrownRecognition API.">ShapeType</a>.Rect) {
         UI.add(<span class="keyword">new</span> Rectangle(brownShape.ShapePoints));
     }
     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (element.ShapeType == <a class="code" href="namespace_brown_recognition_common.html#a86340ddb3d90188573ed7b4484046ec3" title="Enumeration of all the differnet shape types supported by the BrownRecognition API.">ShapeType</a>.Circle) {
         ...
     }
     ...
 }
</pre></div><h2><a class="anchor" id="b"></a>
Calling from C++</h2>
<p>To call the <a class="el" href="class_brown_recognition_a_p_i_1_1_a_p_i.html" title="Entry point for all calls to the BrownRecognition API.">API</a> from unmanged C++ code, a bridge C++ file must created and compiled as managed code. Other unmanaged C++ code will then be able to call functions in that file. Inside the unmanged file, the same logic as in the examples above can be applied with slightly differnet syntax. <br/>
 <br/>
 Example of how to call the <a class="el" href="class_brown_recognition_a_p_i_1_1_a_p_i.html" title="Entry point for all calls to the BrownRecognition API.">API</a> in C++: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Shape Recognition</span>
 <a class="code" href="class_brown_recognition_common_1_1_brown_input_stroke.html" title="Encapsulates an input stroke.">BrownRecognitionCommon::BrownInputStroke</a>^ stroke = <span class="keyword">gcnew</span> <a class="code" href="class_brown_recognition_common_1_1_brown_input_stroke.html" title="Encapsulates an input stroke.">BrownRecognitionCommon::BrownInputStroke</a>(pts, backtrackObject);
 <a class="code" href="class_brown_recognition_common_1_1_brown_shape.html" title="Encapsulates a recognized shape.">BrownRecognitionCommon::BrownShape</a>^ brownShape = <a class="code" href="class_brown_recognition_a_p_i_1_1_a_p_i.html#ac7688bb14d67362c0b3082279dff8d51" title="Takes a single stroke and tries to recognized it as a primitive shape.">BrownRecognitionAPI::API::RecognizeBrownShape</a>(stroke);
 
 <span class="comment">// Template Recognition</span>
 List&lt;BrownRecognitionCommon::BrownInputStroke^&gt;^ inputStrokes = <span class="keyword">gcnew</span> List&lt;BrownRecognitionCommon::BrownInputStroke^&gt;();
 inputStrokes-&gt;Add(stroke);
 List&lt;BrownRecognitionCommon::BrownTemplate^&gt;^ templates = <a class="code" href="class_brown_recognition_a_p_i_1_1_a_p_i.html#a9f1a5fa344eca4e35f70fbc35fcc21ad" title="Attempts to recognize templates from a set of shapes. This method can be used to provide some feedbac...">BrownRecognitionAPI::API::RecognizeBrownTemplate</a>(inputStrokes);
 
 <span class="comment">// Settings</span>
 System::String^ settings = <a class="code" href="class_brown_recognition_a_p_i_1_1_a_p_i.html#ac40d9358eb8dc39addc178098afabe13" title="Returns all the Brown Recognition settings as an XML string (see BrownRecognitionCommon.BrownRecognitionSettings).">BrownRecognitionAPI::API::GetBrownRecognitionSettings</a>();
 <a class="code" href="class_brown_recognition_a_p_i_1_1_a_p_i.html#a31048d83acc9c8a826cba133fd2c6b45" title="Sets all the Brown Recognition settings (see BrownRecognitionCommon.BrownRecognitionSettings).">BrownRecognitionAPI::API::SetBrownRecognitionSettings</a>(settings);
</pre></div><h2><a class="anchor" id="c"></a>
Settings</h2>
<p>The <a class="el" href="class_brown_recognition_a_p_i_1_1_a_p_i.html" title="Entry point for all calls to the BrownRecognition API.">API</a> overs methods to get and set the settings using XML. See <a class="el" href="class_brown_recognition_common_1_1_brown_recognition_settings.html" title="Singelton that encapsulates all the settings used in the BrownRecognition API.">BrownRecognitionCommon.BrownRecognitionSettings</a> for further details on what the settings mean. A typical XML looks like this: </p>
<div class="fragment"><pre class="fragment"> &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;utf-16&quot;</span>?&gt;
 &lt;BrownRecognitionSettings xmlns:xsi=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:xsd=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;
   &lt;OrgChartBlockConnectorDistanceThreshold&gt;25&lt;/OrgChartBlockConnectorDistanceThreshold&gt;
   &lt;OrgChartWidthPolicy&gt;AverageOnChart&lt;/OrgChartWidthPolicy&gt;
   &lt;OrgChartHeightPolicy&gt;AverageOnChart&lt;/OrgChartHeightPolicy&gt;
   &lt;OrgChartHorizontalSpacingPolicy&gt;StickToConstant&lt;/OrgChartHorizontalSpacingPolicy&gt;
   &lt;OrgChartVerticalSpacingPolicy&gt;StickToConstant&lt;/OrgChartVerticalSpacingPolicy&gt;
   &lt;OrgChartConstantHorizontalSpacing&gt;30&lt;/OrgChartConstantHorizontalSpacing&gt;
   &lt;OrgChartConstantVerticalSpacing&gt;30&lt;/OrgChartConstantVerticalSpacing&gt;
   &lt;PieChartMinimumLengthOfLinesInPercentOfCircleRadius&gt;0.2&lt;/PieChartMinimumLengthOfLinesInPercentOfCircleRadius&gt;
   &lt;TableDiagramContainsThreshold&gt;25&lt;/TableDiagramContainsThreshold&gt;
   &lt;TableDiagramAlignmentThreshold&gt;10&lt;/TableDiagramAlignmentThreshold&gt;
   &lt;TableDiagramVerticalLineToleranceInPercentOfLength&gt;0.3&lt;/TableDiagramVerticalLineToleranceInPercentOfLength&gt;
   &lt;TableDiagramHorizontalLineToleranceInPercentOfLength&gt;0.3&lt;/TableDiagramHorizontalLineToleranceInPercentOfLength&gt;
 &lt;/BrownRecognitionSettings&gt;
</pre></div> </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Sat Nov 5 2011 13:05:53 for BrownRecognition API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
